package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/klauspost/compress/zstd"
)

func main() {
	if len(os.Args) != 5 {
		fmt.Fprintf(os.Stderr, "Usage: %s <input> <package> <var> <out>\n", filepath.Base(os.Args[0]))
		os.Exit(2)
	}

	inPath := os.Args[1]
	pkgName := os.Args[2]
	varName := os.Args[3]
	outPath := os.Args[4]

	if pkgName == "" || varName == "" || outPath == "" {
		fmt.Fprintf(os.Stderr, "compress: package, var, and out are required\n")
		os.Exit(2)
	}

	if err := compress(inPath, pkgName, varName, outPath); err != nil {
		fmt.Fprintf(os.Stderr, "compress: %v\n", err)
		os.Exit(1)
	}
}

func compress(inPath, pkgName, varName, outPath string) (err error) {
	if inPath == "" {
		return errors.New("input path is required")
	}

	input, err := os.Open(inPath)
	if err != nil {
		return fmt.Errorf("failed to open input file: %w", err)
	}
	defer input.Close()

	var buf bytes.Buffer
	encoder, err := zstd.NewWriter(&buf, zstd.WithEncoderLevel(zstd.EncoderLevelFromZstd(19)))
	if err != nil {
		return fmt.Errorf("failed to create zstd encoder: %w", err)
	}

	if _, err := io.Copy(encoder, input); err != nil {
		encoder.Close()
		return fmt.Errorf("failed to compress input: %w", err)
	}

	if err := encoder.Close(); err != nil {
		return fmt.Errorf("failed to finalize compression: %w", err)
	}

	if err := writeGoFile(outPath, pkgName, varName, buf.Bytes()); err != nil {
		return err
	}

	if err := os.Remove(inPath); err != nil && !errors.Is(err, os.ErrNotExist) {
		return fmt.Errorf("failed to remove input file: %w", err)
	}

	return nil
}

// writeGoFile renders the compressed binary as a Go source file to avoid
// depending on go:embed; go generate loads this package before generators run,
// so embedding would fail unless the blobs already existed.
func writeGoFile(outPath, pkgName, varName string, data []byte) error {
	if outPath == "" {
		return errors.New("output path is required")
	}

	dir := filepath.Dir(outPath)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("failed to create output directory: %w", err)
		}
	}

	var buf bytes.Buffer
	// Prevent self-embedding blowup: allow excluding these blobs when building
	// the target that we are bundling by using '-tags=skip_leash_entry_embeds'.
	// The generator (go:generate) builds the leash-entry binary with that tag so
	// it does not include previously generated blobs while producing new ones.
	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString("//go:build !skip_leash_entry_embeds\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", pkgName)
	fmt.Fprintf(&buf, "func init() {\n\t%s = []byte{\n", varName)

	for i, b := range data {
		if i%12 == 0 {
			buf.WriteString("\t\t")
		}
		fmt.Fprintf(&buf, "0x%02x,", b)
		if i%12 == 11 || i == len(data)-1 {
			buf.WriteString("\n")
		} else {
			buf.WriteString(" ")
		}
	}

	buf.WriteString("\t}\n}")

	tmp, err := os.CreateTemp(dir, filepath.Base(outPath)+".tmp-*")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	tmpPath := tmp.Name()

	if _, err := tmp.Write(buf.Bytes()); err != nil {
		tmp.Close()
		os.Remove(tmpPath)
		return fmt.Errorf("failed to write output: %w", err)
	}
	if err := tmp.Chmod(0o644); err != nil {
		tmp.Close()
		os.Remove(tmpPath)
		return fmt.Errorf("failed to set permissions: %w", err)
	}
	if err := tmp.Close(); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("failed to close temporary file: %w", err)
	}
	if err := os.Rename(tmpPath, outPath); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("failed to finalize output: %w", err)
	}
	return nil
}
