package log2cedar

import (
	"bufio"
	"fmt"
	"io"
	"sort"
	"strings"
)

type resourceKey struct {
	Type  string
	Value string
}

type suggestion struct {
	Action   string
	Resource resourceKey
}

type Generator struct {
	resources     map[string]map[resourceKey]struct{}
	matchDecision string
	policyEffect  string
}

func NewGenerator(targetAllowed bool) *Generator {
	decision := "denied"
	effect := "permit"
	if targetAllowed {
		decision = "allowed"
		effect = "forbid"
	}
	return &Generator{
		resources:     make(map[string]map[resourceKey]struct{}),
		matchDecision: decision,
		policyEffect:  effect,
	}
}

func (g *Generator) Ingest(r io.Reader) error {
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		line := scanner.Text()
		g.ProcessLine(line)
	}
	if err := scanner.Err(); err != nil {
		return fmt.Errorf("failed reading log: %w", err)
	}
	return nil
}

func (g *Generator) ProcessLine(line string) {
	fields, ok := parseKeyValuePairs(line)
	if !ok {
		return
	}
	if !matchesDecision(fields, g.matchDecision) {
		return
	}

	for _, s := range suggestionsFromFields(fields) {
		g.addSuggestion(s)
	}
}

func (g *Generator) addSuggestion(s suggestion) {
	if s.Action == "" || s.Resource.Type == "" || s.Resource.Value == "" {
		return
	}
	if _, ok := g.resources[s.Action]; !ok {
		g.resources[s.Action] = make(map[resourceKey]struct{})
	}
	g.resources[s.Action][s.Resource] = struct{}{}
}

func (g *Generator) Render() string {
	if len(g.resources) == 0 {
		return ""
	}

	var actions []string
	for action := range g.resources {
		actions = append(actions, action)
	}
	sort.Strings(actions)

	var builder strings.Builder
	builder.WriteString("// Generated by log2cedar. Review before applying.\n\n")

	for idx, action := range actions {
		resources := g.resources[action]
		ordered := make([]resourceKey, 0, len(resources))
		for res := range resources {
			ordered = append(ordered, res)
		}
		sort.Slice(ordered, func(i, j int) bool {
			if ordered[i].Type == ordered[j].Type {
				return ordered[i].Value < ordered[j].Value
			}
			return ordered[i].Type < ordered[j].Type
		})

		builder.WriteString(fmt.Sprintf("%s(\n", g.policyEffect))
		builder.WriteString("    principal,\n")
		builder.WriteString(fmt.Sprintf("    action == Action::\"%s\",\n", actionToAction(action)))

		if len(ordered) == 1 {
			res := ordered[0]
			builder.WriteString(fmt.Sprintf("    resource == %s::\"%s\"\n", res.Type, escapeCedarString(res.Value)))
			builder.WriteString(");\n")
		} else {
			builder.WriteString("    resource\n")
			builder.WriteString(")\n")
			builder.WriteString("when {\n")
			builder.WriteString("    resource in [\n")
			for i, res := range ordered {
				builder.WriteString(fmt.Sprintf("        %s::\"%s\"", res.Type, escapeCedarString(res.Value)))
				if i < len(ordered)-1 {
					builder.WriteString(",")
				}
				builder.WriteString("\n")
			}
			builder.WriteString("    ]\n")
			builder.WriteString("};\n")
		}
		if idx < len(actions)-1 {
			builder.WriteString("\n")
		}
	}

	return builder.String()
}

func parseKeyValuePairs(line string) (map[string]string, bool) {
	if !strings.Contains(line, "=") {
		return nil, false
	}

	result := make(map[string]string)
	i := 0
	n := len(line)

	for i < n {
		for i < n && line[i] == ' ' {
			i++
		}
		if i >= n {
			break
		}

		startKey := i
		for i < n && line[i] != '=' {
			i++
		}
		if i >= n {
			break
		}
		key := strings.TrimSpace(line[startKey:i])
		i++
		if i >= n {
			result[key] = ""
			break
		}

		var value string
		if line[i] == '"' {
			i++
			var sb strings.Builder
			for i < n {
				if line[i] == '\\' && i+1 < n {
					sb.WriteByte(line[i+1])
					i += 2
					continue
				}
				if line[i] == '"' {
					break
				}
				sb.WriteByte(line[i])
				i++
			}
			value = sb.String()
			for i < n && line[i] != ' ' {
				i++
			}
		} else {
			startValue := i
			for i < n && line[i] != ' ' {
				i++
			}
			value = line[startValue:i]
		}
		result[key] = strings.TrimSpace(value)
	}

	return result, len(result) > 0
}

func matchesDecision(fields map[string]string, decision string) bool {
	value, ok := fields["decision"]
	if !ok {
		return false
	}
	return strings.EqualFold(value, decision)
}

func actionToAction(irOp string) string {
	switch irOp {
	case "open":
		return "FileOpen"
	case "read":
		return "FileOpenReadOnly"
	case "write":
		return "FileOpenReadWrite"
	case "exec":
		return "ProcessExec"
	case "connect":
		return "NetworkConnect"
	default:
		return irOp
	}
}

func suggestionsFromFields(fields map[string]string) []suggestion {
	event := fields["event"]
	switch event {
	case "http.request", "net.send":
		addr := strings.TrimSpace(fields["addr"])
		if addr == "" {
			return nil
		}
		return []suggestion{{
			Action: "connect",
			Resource: resourceKey{
				Type:  "Host",
				Value: addr,
			},
		}}
	case "proc.exec":
		path := firstNonEmpty(fields["path"], fields["argv"], fields["exe"])
		path = strings.TrimSpace(path)
		if path == "" {
			return nil
		}
		return []suggestion{{
			Action: "exec",
			Resource: resourceKey{
				Type:  "File",
				Value: path,
			},
		}}
	case "file.open":
		return buildFileSuggestion("open", fields)
	case "file.open:ro":
		return buildFileSuggestion("read", fields)
	case "file.open:rw":
		return buildFileSuggestion("write", fields)
	default:
		return nil
	}
}

func buildFileSuggestion(action string, fields map[string]string) []suggestion {
	path := strings.TrimSpace(fields["path"])
	if path == "" {
		return nil
	}
	resourceType := "File"
	if strings.HasSuffix(path, "/") {
		resourceType = "Dir"
	}
	return []suggestion{{
		Action: action,
		Resource: resourceKey{
			Type:  resourceType,
			Value: path,
		},
	}}
}

func firstNonEmpty(values ...string) string {
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v != "" {
			if strings.HasPrefix(v, "/") {
				return v
			}
			if idx := strings.IndexByte(v, ' '); idx > 0 {
				candidate := strings.TrimSpace(v[:idx])
				if strings.HasPrefix(candidate, "/") {
					return candidate
				}
			}
		}
	}
	return ""
}

func escapeCedarString(in string) string {
	in = strings.ReplaceAll(in, "\\", "\\\\")
	in = strings.ReplaceAll(in, "\"", "\\\"")
	return in
}
